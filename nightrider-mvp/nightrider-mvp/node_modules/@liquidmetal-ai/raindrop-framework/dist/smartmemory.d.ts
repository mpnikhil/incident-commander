import { ActorState, ActorStub } from './actor.js';
export type SessionId = string;
export interface SmartMemory {
    getWorkingMemorySession(sessionId: string): Promise<ActorStub<SmartWorkingMemory>>;
    startWorkingMemorySession(): Promise<{
        sessionId: SessionId;
        workingMemory: ActorStub<SmartWorkingMemory>;
    }>;
    rehydrateSession(sessionId: string, summaryOnly?: boolean): Promise<{
        sessionId: string;
        workingMemory: ActorStub<SmartWorkingMemory>;
        success: boolean;
        message: string;
        entriesRestored?: number;
    }>;
    searchEpisodicMemory(terms: string, options?: {
        nMostRecent?: number;
        startTime?: Date;
        endTime?: Date;
    }): Promise<{
        results: Array<{
            sessionId: string;
            summary: string;
            agent: string;
            entryCount: number;
            timelineCount: number;
            duration: number;
            createdAt: Date;
            score?: number;
        }>;
        pagination: {
            total: number;
            page: number;
            pageSize: number;
            totalPages: number;
            hasMore: boolean;
        };
    }>;
    getSemanticMemory(objectId: string): Promise<{
        success: boolean;
        document?: Record<string, unknown>;
        error?: string;
    }>;
    searchSemanticMemory(needle: string): Promise<{
        success: boolean;
        documentSearchResponse?: {
            results: Array<{
                chunkSignature?: string;
                text?: string;
                source?: string | {
                    object?: string;
                };
                payloadSignature?: string;
                score?: number;
                embed?: Float32Array;
                type?: string;
            }>;
        };
        error?: string;
    }>;
    putSemanticMemory(document: Record<string, unknown>): Promise<{
        success: boolean;
        objectId?: string;
        error?: string;
    }>;
    deleteSemanticMemory(objectId: string): Promise<{
        success: boolean;
        error?: string;
    }>;
    getProceduralMemory(id?: string): Promise<ActorStub<SmartProceduralMemory>>;
}
export type WorkingMemoryQuery = {
    timeline?: string;
    key?: string;
    nMostRecent?: number;
    startTime?: Date;
    endTime?: Date;
};
export type NewMemoryEntry = {
    timeline?: string;
    key?: string;
    content: string;
    agent?: string;
    sessionId?: string;
    at?: Date;
};
export type MemoryEntry = {
    id: string;
    in: SessionId;
    timeline: string;
    by: string;
    dueTo: string;
    content: string;
    at: Date;
    key?: string;
    agent?: string;
};
export type WorkingMemorySearchQuery = {
    timeline?: string;
    terms: string;
    nMostRecent?: number;
    startTime?: Date;
    endTime?: Date;
};
export type ProcedureEntry = {
    key: string;
    value: string;
    createdAt: Date;
    updatedAt: Date;
};
export type ProceduralMemorySearchQuery = {
    terms: string;
    nMostRecent?: number;
    searchKeys?: boolean;
    searchValues?: boolean;
};
export interface SmartWorkingMemory {
    state: ActorState;
    env: unknown;
    endSession(flush: boolean): Promise<void>;
    getMemory(entry: WorkingMemoryQuery): Promise<MemoryEntry[] | null>;
    searchMemory(terms: WorkingMemorySearchQuery): Promise<MemoryEntry[] | null>;
    putMemory(entry: NewMemoryEntry): Promise<string>;
    deleteMemory(entryId: string): Promise<void>;
    summarizeMemory(memories: MemoryEntry[], systemPrompt?: string): Promise<{
        summary: string;
        entries: Record<string, MemoryEntry[]>;
        metadata: {
            duration: number;
            timelineCount: number;
            entryCount: number;
            agent: string;
        };
    }>;
    rehydrateSession(sessionId: string, summaryOnly?: boolean): Promise<{
        success: boolean;
        message: string;
        entriesRestored?: number;
    }>;
    getRehydrationStatus(): Promise<{
        status: 'initiated' | 'processing' | 'completed' | 'failed';
        sessionId?: string;
        entriesRestored?: number;
        error?: string;
        initiatedAt?: string;
        completedAt?: string;
    } | null>;
    searchEpisodicMemory(terms: string): Promise<{
        results: Array<{
            chunkSignature?: string;
            text?: string;
            source?: string | {
                object?: string;
            };
            payloadSignature?: string;
            score?: number;
            embed?: Float32Array;
            type?: string;
        }>;
        pagination?: {
            total: number;
            page: number;
            pageSize: number;
            totalPages: number;
            hasMore: boolean;
        };
    }>;
    getSemanticMemory(objectId: string): Promise<{
        success: boolean;
        document?: Record<string, unknown>;
        error?: string;
    }>;
    searchSemanticMemory(needle: string): Promise<{
        success: boolean;
        documentSearchResponse?: {
            results: Array<{
                chunkSignature?: string;
                text?: string;
                source?: string | {
                    object?: string;
                };
                payloadSignature?: string;
                score?: number;
                embed?: Float32Array;
                type?: string;
            }>;
        };
        error?: string;
    }>;
    putSemanticMemory(document: Record<string, unknown>): Promise<{
        success: boolean;
        objectId?: string;
        error?: string;
    }>;
    deleteSemanticMemory(objectId: string): Promise<{
        success: boolean;
        error?: string;
    }>;
}
export interface SmartProceduralMemory {
    state: ActorState;
    env: unknown;
    putProcedure(key: string, value: string): Promise<void>;
    getProcedure(key: string): Promise<string | null>;
    deleteProcedure(key: string): Promise<boolean>;
    listProcedures(): Promise<ProcedureEntry[]>;
    searchProcedures(query: ProceduralMemorySearchQuery): Promise<ProcedureEntry[] | null>;
}
//# sourceMappingURL=smartmemory.d.ts.map