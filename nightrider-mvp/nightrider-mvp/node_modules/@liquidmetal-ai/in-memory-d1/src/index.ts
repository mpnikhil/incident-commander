import { readdir, readFile } from 'node:fs/promises';
import { extname, join } from 'node:path';
import { Miniflare } from 'miniflare';

export async function makeD1Database(params?: { migrations?: string; fixtures?: string[] }): Promise<D1Database> {
  // create a miniflare instance that has a single d1 database
  //
  // miniflare must have a script provided to it
  const mf = new Miniflare({
    modules: true,
    script: `
    export default {
      async fetch(request, env, ctx) {
        return new Response("Hello Miniflare!");
      }
    }
    `,
    d1Databases: {
      DB: '1234', // the database id doesn't matter
    },
  });

  // get the database from miniflare
  const db = await mf.getD1Database('DB');

  // read the migrations directory
  const dir = params?.migrations || './migrations';
  const migrations = (await readdir(dir))
    .filter((file) => extname(file) === '.sql')
    .filter((file) => !file.includes('seed'))
    .sort()
    .map((file) => join(dir, file));

  // add read the fixture files after the migrations
  const files = migrations.concat(params?.fixtures || []);

  // parse each migration file into separate instructions
  // D1Database does not like comments or newlines
  for (const file of files) {
    const sql = await readFile(file);
    const statements = sql.toString().split(';');
    for (const statement of statements) {
      const lines = statement.split('\n').filter((line) => !line.includes('--') && line.trim().length > 0);
      if (lines.length === 0) {
        continue;
      }

      const query = lines.join('') + ';';
      await db.exec(query);
    }
  }

  // database is ready to go
  return db;
}
