/**
 * CONTROLLER for incident-orchestrator Service
 *
 * PRD REQUIREMENTS:
 * CONTROLLER (orchestration):
 * - handleIncident(alert: IncidentAlert): Promise<ProcessingResult>
 * - executeAgentWorkflow(incidentId: string): Promise<WorkflowResult>
 * - WORKFLOWS: Agent receives alert → Agent assesses → Agent gathers data via MCP → Agent analyzes → Agent decides/executes
 * - INTEGRATIONS: External observability APIs, email service, knowledge base search
 * - MODEL-VIEW COORDINATION: Coordinates between API requests and data storage
 * - ERROR RECOVERY: Retry failed API calls, fallback to cached data, escalate on repeated failures
 *
 * MUST IMPLEMENT:
 * 1. Main incident processing workflow orchestration
 * 2. Agent-driven analysis using AI models
 * 3. MCP tool coordination for data gathering
 * 4. Service-to-service communication management
 * 5. Error recovery and retry logic
 * 6. Workflow state tracking
 *
 * INTERFACES TO EXPORT:
 * - handleIncident(alert: IncidentAlert): Promise<ProcessingResult>
 * - executeAgentWorkflow(incidentId: string): Promise<WorkflowResult>
 * - performAgentAssessment(incident: Incident): Promise<GatherDataStrategy>
 * - gatherDataViaMCP(strategy: GatherDataStrategy): Promise<GatheredData>
 * - performAgentAnalysis(incident: Incident, data: GatheredData): Promise<RCAResult>
 *
 * IMPORTS NEEDED:
 * - From shared types: IncidentAlert, Incident, ProcessingResult, GatherDataStrategy, GatheredData, RCAResult
 * - From env: env.AI, env.SRE_MCP, env.INCIDENT_DATA, env.RCA_ENGINE, env.REMEDIATION_COORDINATOR, env.logger
 * - From other layers: model functions for validation and business rules
 *
 * BUSINESS RULES:
 * - Agent is first responder for all incidents
 * - Agent determines what data to gather based on incident type
 * - Agent performs all analysis using AI models
 * - Autonomous actions only for low-risk operations
 * - High-risk actions require approval and escalation
 *
 * ERROR HANDLING:
 * - Try-catch around all external service calls
 * - Exponential backoff for retries
 * - Circuit breaker for failing services
 * - Fallback to cached data when external services fail
 * - Log all errors with full context
 *
 * INTEGRATION POINTS:
 * - Called by sre-api service for incident processing
 * - Calls rca-engine service for analysis coordination
 * - Calls remediation-coordinator service for action execution
 * - Calls incident-data actor for state management
 * - Uses sre-mcp service for data gathering
 */

import {
  IncidentAlert,
  Incident,
  IncidentSeverity,
  IncidentStatus,
  ProcessingResult,
  GatherDataStrategy,
  GatheredData,
  RCAResult,
  RecommendedAction,
  ActionRiskLevel,
  ProcessingError,
  LogEntry,
  MetricData,
  AlertData,
  SystemStatus,
  RunbookEntry
} from '../types/shared';

import * as Model from './model';

// Environment interface - this would be generated by the framework
interface Environment {
  AI: {
    run(systemPrompt: string, userPrompt: string, model?: string): Promise<string>;
  };
  SRE_MCP: {
    getLogs(params: { services: string[]; time_range: string; search_terms?: string[] }): Promise<LogEntry[]>;
    getMetrics(params: { metrics: string[]; time_range: string; services?: string[] }): Promise<MetricData[]>;
    getAlerts(params: { services?: string[]; time_range: string; status?: string }): Promise<AlertData[]>;
    getSystemStatus(params: { services?: string[] }): Promise<SystemStatus[]>;
    searchRunbooks(params: { query: string; incident_types?: string[] }): Promise<RunbookEntry[]>;
  };
  INCIDENT_DATA: {
    createIncident(incident: Partial<Incident>): Promise<Incident>;
    updateIncident(id: string, updates: Partial<Incident>): Promise<Incident>;
    getIncident(id: string): Promise<Incident>;
  };
  RCA_ENGINE: {
    performRCA(incident: Incident, data: GatheredData): Promise<RCAResult>;
  };
  REMEDIATION_COORDINATOR: {
    executeRemediation(actions: RecommendedAction[]): Promise<{ success: boolean; executed_actions: string[] }>;
  };
  logger: {
    info(message: string, metadata?: any): void;
    warn(message: string, metadata?: any): void;
    error(message: string, metadata?: any): void;
  };
}

// Circuit breaker state for each service
interface CircuitBreakerState {
  failures: number;
  lastFailureTime: number;
  isOpen: boolean;
}

const circuitBreakers: Record<string, CircuitBreakerState> = {};
const CIRCUIT_BREAKER_THRESHOLD = 5;
const CIRCUIT_BREAKER_RESET_TIME = 30000; // 30 seconds

/**
 * Implements exponential backoff retry logic
 */
async function withRetry<T>(
  operation: () => Promise<T>,
  maxAttempts: number = 3,
  baseDelay: number = 1000,
  serviceName?: string
): Promise<T> {
  let lastError: Error;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      const result = await operation();

      // Reset circuit breaker on success
      if (serviceName && circuitBreakers[serviceName]) {
        circuitBreakers[serviceName].failures = 0;
        circuitBreakers[serviceName].isOpen = false;
      }

      return result;
    } catch (error) {
      lastError = error as Error;

      // Update circuit breaker
      if (serviceName) {
        if (!circuitBreakers[serviceName]) {
          circuitBreakers[serviceName] = { failures: 0, lastFailureTime: 0, isOpen: false };
        }

        const breaker = circuitBreakers[serviceName];
        breaker.failures++;
        breaker.lastFailureTime = Date.now();

        if (breaker.failures >= CIRCUIT_BREAKER_THRESHOLD) {
          breaker.isOpen = true;
        }
      }

      if (attempt === maxAttempts) {
        throw lastError;
      }

      const delay = baseDelay * Math.pow(2, attempt - 1);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  throw lastError!;
}

/**
 * Checks if circuit breaker allows operation
 */
function isCircuitBreakerOpen(serviceName: string): boolean {
  const breaker = circuitBreakers[serviceName];
  if (!breaker) return false;

  if (breaker.isOpen) {
    // Check if enough time has passed to reset
    if (Date.now() - breaker.lastFailureTime > CIRCUIT_BREAKER_RESET_TIME) {
      breaker.isOpen = false;
      breaker.failures = 0;
      return false;
    }
    return true;
  }

  return false;
}

/**
 * Main incident processing workflow
 * Agent receives alert → Agent assesses → Agent gathers data via MCP → Agent analyzes → Agent decides/executes
 */
export async function handleIncident(alert: IncidentAlert, env: Environment): Promise<ProcessingResult> {
  const startTime = Date.now();
  let incident: Incident | undefined;

  try {
    env.logger.info('Starting incident processing', { alert });

    // Step 1: Create incident from alert
    incident = await withRetry(
      () => env.INCIDENT_DATA.createIncident({
        title: `${alert.alert_type}: ${alert.message}`,
        description: alert.message,
        severity: mapSeverity(alert.severity),
        status: IncidentStatus.RECEIVED,
        source: alert.source,
        affected_services: alert.affected_services,
        created_at: alert.timestamp,
        updated_at: new Date().toISOString(),
        metadata: {
          ...alert.metadata,
          alert_type: alert.alert_type
        }
      }),
      3,
      1000,
      'INCIDENT_DATA'
    );

    env.logger.info('Incident created', { incident_id: incident.id });

    // Step 2: Agent performs initial assessment
    const strategy = await performAgentAssessment(incident, env);

    // Update incident status
    incident = await withRetry(
      () => env.INCIDENT_DATA.updateIncident(incident!.id, {
        status: IncidentStatus.INVESTIGATING
      }),
      3,
      1000,
      'INCIDENT_DATA'
    );

    // Step 3: Agent gathers data via MCP
    const gatheredData = await gatherDataViaMCP(strategy, env);

    // Update incident status
    incident = await withRetry(
      () => env.INCIDENT_DATA.updateIncident(incident!.id, {
        status: IncidentStatus.ANALYZING
      }),
      3,
      1000,
      'INCIDENT_DATA'
    );

    // Step 4: Agent performs RCA analysis
    const rcaResult = await performAgentAnalysis(incident, gatheredData, env);

    // Step 5: Agent decides and executes actions
    const timeElapsed = Date.now() - startTime;
    const shouldEscalate = Model.shouldEscalate(incident, timeElapsed);

    let executedActions: string[] = [];

    if (shouldEscalate) {
      // Escalate incident
      await withRetry(
        () => env.INCIDENT_DATA.updateIncident(incident!.id, {
          status: IncidentStatus.ESCALATED
        }),
        3,
        1000,
        'INCIDENT_DATA'
      );

      env.logger.warn('Incident escalated due to time/failure constraints', {
        incident_id: incident!.id,
        time_elapsed: timeElapsed
      });

      return Model.formatProcessingResult({
        status: 'escalated',
        agent_analysis: rcaResult,
        actions_taken: [],
        timeline: [
          `${new Date(alert.timestamp).toISOString()} - Alert received`,
          `${new Date().toISOString()} - Escalated due to processing constraints`
        ]
      });
    } else {
      // Execute recommended actions if low-risk
      const safeActions = rcaResult.recommended_actions.filter(action =>
        Model.canExecuteAutonomously(action)
      );

      if (safeActions.length > 0) {
        try {
          const remediationResult = await executeRecommendedActions(safeActions, env);
          executedActions = remediationResult.executed_actions;

          // Update incident status to remediating
          await withRetry(
            () => env.INCIDENT_DATA.updateIncident(incident!.id, {
              status: IncidentStatus.REMEDIATING
            }),
            3,
            1000,
            'INCIDENT_DATA'
          );
        } catch (error) {
          env.logger.error('Failed to execute remediation actions', {
            incident_id: incident!.id,
            error: (error as Error).message
          });
        }
      }
    }

    // Mark incident as resolved if actions were successful
    if (executedActions.length > 0) {
      await withRetry(
        () => env.INCIDENT_DATA.updateIncident(incident!.id, {
          status: IncidentStatus.RESOLVED
        }),
        3,
        1000,
        'INCIDENT_DATA'
      );
    }

    return Model.formatProcessingResult({
      status: executedActions.length > 0 ? 'completed' : 'in_progress',
      agent_analysis: rcaResult,
      actions_taken: executedActions,
      timeline: [
        `${new Date(alert.timestamp).toISOString()} - Alert received`,
        `${new Date().toISOString()} - Analysis completed`,
        ...executedActions.map(action => `${new Date().toISOString()} - Executed: ${action}`)
      ]
    });

  } catch (error) {
    env.logger.error('Failed to handle incident', {
      error: (error as Error).message,
      alert,
      stack: (error as Error).stack
    });

    // Try to update incident status to escalated
    if (incident) {
      try {
        await env.INCIDENT_DATA.updateIncident(incident!.id, {
          status: IncidentStatus.ESCALATED,
          metadata: {
            ...incident.metadata,
            failed_attempts: (incident.metadata?.failed_attempts || 0) + 1,
            last_error: (error as Error).message
          }
        });
      } catch (updateError) {
        env.logger.error('Failed to update incident after processing failure', {
          incident_id: incident!.id,
          error: (updateError as Error).message
        });
      }
    }

    return Model.formatProcessingResult({
      status: 'escalated',
      agent_analysis: {
        incident_id: incident?.id || `INC-${Date.now()}`,
        root_cause: 'Processing failed - escalated for manual intervention',
        evidence: [`Processing error: ${(error as Error).message}`],
        confidence_score: 0,
        contributing_factors: ['System processing failure'],
        recommended_actions: [],
        analysis_timeline: [`${new Date().toISOString()} - Processing failed`],
        prevention_strategies: ['Investigate system failures', 'Improve error handling']
      },
      actions_taken: [],
      timeline: [`${new Date().toISOString()} - Processing failed and escalated`]
    });
  }
}

/**
 * Executes agent workflow for existing incident
 */
export async function executeAgentWorkflow(incidentId: string, env: Environment): Promise<Model.WorkflowResult> {
  try {
    env.logger.info('Executing agent workflow', { incident_id: incidentId });

    // Get existing incident
    const incident = await withRetry(
      () => env.INCIDENT_DATA.getIncident(incidentId),
      3,
      1000,
      'INCIDENT_DATA'
    );

    // Perform assessment and analysis
    const strategy = await performAgentAssessment(incident, env);
    const gatheredData = await gatherDataViaMCP(strategy, env);
    const rcaResult = await performAgentAnalysis(incident, gatheredData, env);

    // Execute safe actions
    const safeActions = rcaResult.recommended_actions.filter(action =>
      Model.canExecuteAutonomously(action)
    );

    let executedActions: string[] = [];
    if (safeActions.length > 0) {
      const remediationResult = await executeRecommendedActions(safeActions, env);
      executedActions = remediationResult.executed_actions;
    }

    return {
      workflow_completed: true,
      status: 'completed',
      actions_taken: executedActions,
      timeline: [
        `${new Date().toISOString()} - Workflow executed`,
        ...executedActions.map(action => `${new Date().toISOString()} - ${action}`)
      ]
    };

  } catch (error) {
    env.logger.error('Failed to execute agent workflow', {
      incident_id: incidentId,
      error: (error as Error).message
    });

    return {
      workflow_completed: false,
      status: 'failed',
      actions_taken: [],
      timeline: [`${new Date().toISOString()} - Workflow failed: ${(error as Error).message}`]
    };
  }
}

/**
 * Agent performs initial assessment to determine data gathering strategy
 */
export async function performAgentAssessment(incident: Incident, env: Environment): Promise<GatherDataStrategy> {
  const isHighSeverity = incident.severity === IncidentSeverity.P0 || incident.severity === IncidentSeverity.P1;
  const model = isHighSeverity ? 'deepseek-v3' : 'llama-3.1-8b-instruct';

  const systemPrompt = `You are an expert SRE agent performing initial incident assessment.
Analyze the incident details and determine the optimal data gathering strategy.

${isHighSeverity ? 'URGENT ' + incident.severity + ' incident - perform expedited analysis.' : 'Perform comprehensive analysis.'}

Return a JSON object with the following structure:
{
  "incident_type": "string describing the type of incident",
  "required_logs": ["array", "of", "services", "to", "collect", "logs", "from"],
  "required_metrics": ["array", "of", "metrics", "to", "collect"],
  "time_range": "time range for data collection (e.g., '1h', '30m')",
  "search_terms": ["optional", "array", "of", "search", "terms"]
}`;

  const userPrompt = `Analyze this incident and provide data gathering strategy:

Title: ${incident.title}
Description: ${incident.description}
Severity: ${incident.severity}
Affected Services: ${incident.affected_services.join(', ')}
Source: ${incident.source}
Metadata: ${JSON.stringify(incident.metadata, null, 2)}`;

  try {
    const response = await withRetry(
      () => env.AI.run(systemPrompt, userPrompt, model),
      3,
      1000,
      'AI'
    );

    const strategy = JSON.parse(response) as GatherDataStrategy;

    // Validate and set defaults
    if (!strategy.time_range) {
      strategy.time_range = isHighSeverity ? '30m' : '1h';
    }

    if (!strategy.required_logs || strategy.required_logs.length === 0) {
      strategy.required_logs = incident.affected_services;
    }

    env.logger.info('Agent assessment completed', {
      incident_id: incident!.id,
      strategy
    });

    return strategy;

  } catch (error) {
    env.logger.error('Failed to perform agent assessment', {
      incident_id: incident!.id,
      error: (error as Error).message
    });

    // Fallback strategy
    return {
      incident_type: 'unknown',
      required_logs: incident.affected_services,
      required_metrics: ['error_rate', 'response_time', 'cpu_usage', 'memory_usage'],
      time_range: isHighSeverity ? '30m' : '1h',
      search_terms: ['error', 'timeout', 'failure']
    };
  }
}

/**
 * Gather data via MCP tools based on strategy
 */
export async function gatherDataViaMCP(strategy: GatherDataStrategy, env: Environment): Promise<GatheredData> {
  const gatheredData: GatheredData = {
    logs: [],
    metrics: [],
    alerts: [],
    system_status: [],
    runbooks: []
  };

  const maxDataSize = 1000; // Limit data size to prevent memory issues

  // Gather logs
  if (strategy.required_logs.length > 0 && (env as any).SRE_MCP) {
    if (!isCircuitBreakerOpen('SRE_MCP_LOGS')) {
      try {
        const logs = await withRetry(
          () => (env as any).SRE_MCP.getLogs({
            services: strategy.required_logs,
            time_range: strategy.time_range,
            search_terms: strategy.search_terms
          }),
          3,
          1000,
          'SRE_MCP_LOGS'
        );
        gatheredData.logs = (logs as any[]).slice(0, maxDataSize);
      } catch (error) {
        env.logger.warn('Failed to gather logs', { error: (error as Error).message });
      }
    }
  }

  // Gather metrics
  if (strategy.required_metrics.length > 0 && (env as any).SRE_MCP) {
    if (!isCircuitBreakerOpen('SRE_MCP_METRICS')) {
      try {
        const metrics = await withRetry(
          () => (env as any).SRE_MCP.getMetrics({
            metrics: strategy.required_metrics,
            time_range: strategy.time_range,
            services: strategy.required_logs
          }),
          3,
          1000,
          'SRE_MCP_METRICS'
        );
        gatheredData.metrics = (metrics as any[]).slice(0, maxDataSize);
      } catch (error) {
        env.logger.warn('Failed to gather metrics', { error: (error as Error).message });
      }
    }
  }

  // Gather alerts
  if ((env as any).SRE_MCP && !isCircuitBreakerOpen('SRE_MCP_ALERTS')) {
    try {
      const alerts = await withRetry(
        () => (env as any).SRE_MCP.getAlerts({
          services: strategy.required_logs,
          time_range: strategy.time_range,
          status: 'firing'
        }),
        3,
        1000,
        'SRE_MCP_ALERTS'
      );
      gatheredData.alerts = (alerts as any[]).slice(0, maxDataSize);
    } catch (error) {
      env.logger.warn('Failed to gather alerts', { error: (error as Error).message });
    }
  }

  // Gather system status
  if ((env as any).SRE_MCP && !isCircuitBreakerOpen('SRE_MCP_STATUS')) {
    try {
      const systemStatus = await withRetry(
        () => (env as any).SRE_MCP.getSystemStatus({
          services: strategy.required_logs
        }),
        3,
        1000,
        'SRE_MCP_STATUS'
      );
      gatheredData.system_status = (systemStatus as any[]).slice(0, maxDataSize);
    } catch (error) {
      env.logger.warn('Failed to gather system status', { error: (error as Error).message });
    }
  }

  // Search runbooks
  if ((env as any).SRE_MCP && !isCircuitBreakerOpen('SRE_MCP_RUNBOOKS')) {
    try {
      const runbooks = await withRetry(
        () => (env as any).SRE_MCP.searchRunbooks({
          query: strategy.incident_type,
          incident_types: [strategy.incident_type]
        }),
        3,
        1000,
        'SRE_MCP_RUNBOOKS'
      );
      gatheredData.runbooks = (runbooks as any[]).slice(0, maxDataSize);
    } catch (error) {
      env.logger.warn('Failed to search runbooks', { error: (error as Error).message });
    }
  }

  env.logger.info('Data gathering completed', {
    logs_count: gatheredData.logs.length,
    metrics_count: gatheredData.metrics.length,
    alerts_count: gatheredData.alerts.length,
    system_status_count: gatheredData.system_status.length,
    runbooks_count: gatheredData.runbooks.length
  });

  return gatheredData;
}

/**
 * Agent performs RCA analysis using gathered data and AI
 */
export async function performAgentAnalysis(
  incident: Incident,
  data: GatheredData,
  env: Environment
): Promise<RCAResult> {
  try {
    const result = await withRetry(
      () => env.RCA_ENGINE.performRCA(incident, data),
      3,
      1000,
      'RCA_ENGINE'
    );

    // Validate analysis results
    if (result.confidence_score < 0 || result.confidence_score > 1) {
      throw new ProcessingError('Invalid confidence score');
    }

    // Calculate risk levels for recommended actions
    result.recommended_actions = result.recommended_actions.map(action => ({
      ...action,
      risk_level: Model.calculateRiskLevel(action)
    }));

    env.logger.info('Agent analysis completed', {
      incident_id: incident!.id,
      confidence_score: result.confidence_score,
      actions_count: result.recommended_actions.length
    });

    return result;

  } catch (error) {
    env.logger.error('Failed to perform agent analysis', {
      incident_id: incident!.id,
      error: (error as Error).message
    });

    // Return fallback analysis
    return {
      incident_id: incident!.id,
      root_cause: 'Analysis failed - manual investigation required',
      evidence: [`Analysis error: ${(error as Error).message}`],
      confidence_score: 0.1,
      contributing_factors: ['System analysis failure'],
      recommended_actions: [],
      analysis_timeline: [`${new Date().toISOString()} - Analysis failed`],
      prevention_strategies: ['Investigate analysis system', 'Implement manual fallback procedures']
    };
  }
}

/**
 * Execute recommended actions via remediation coordinator
 */
export async function executeRecommendedActions(
  actions: RecommendedAction[],
  env: Environment
): Promise<{ success: boolean; executed_actions: string[] }> {
  try {
    const result = await withRetry(
      () => env.REMEDIATION_COORDINATOR.executeRemediation(actions),
      3,
      1000,
      'REMEDIATION_COORDINATOR'
    );

    env.logger.info('Actions executed successfully', {
      executed_actions: result.executed_actions
    });

    return result;

  } catch (error) {
    env.logger.error('Failed to execute recommended actions', {
      error: (error as Error).message,
      actions: actions.map(a => a.action_type)
    });

    return {
      success: false,
      executed_actions: []
    };
  }
}

/**
 * Maps alert severity to incident severity
 */
function mapSeverity(alertSeverity: string): IncidentSeverity {
  switch (alertSeverity.toUpperCase()) {
    case 'P0':
    case 'CRITICAL':
      return IncidentSeverity.P0;
    case 'P1':
    case 'HIGH':
      return IncidentSeverity.P1;
    case 'P2':
    case 'MEDIUM':
      return IncidentSeverity.P2;
    case 'P3':
    case 'LOW':
      return IncidentSeverity.P3;
    default:
      return IncidentSeverity.P2;
  }
}